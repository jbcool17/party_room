const CubeForestRender = React.createClass({
	render(){
		var scene, camera, renderer;
		var cubeGeometry, cube, material;
		var sphereGeometry, sphere;
		var objects = [];
		var lastTime;

		//++++++++++++++++++++++++++++++++++++++++++++
		//++++++++++++++++++++++++++++++++++++++++++++
		//Setup Scene and Effects
		scene = new THREE.Scene();
		scene.fog = new THREE.FogExp2(0x000000, 0.001);

		//++++++++++++++++++++++++++++++++++++++++++++
		//++++++++++++++++++++++++++++++++++++++++++++
		//CAMERA
		camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
		camera.position.x = -10;
		camera.position.y = 0;
		camera.position.z = 10;

		//++++++++++++++++++++++++++++++++++++++++++++
		//++++++++++++++++++++++++++++++++++++++++++++
		//Setup renderer
		renderer = new THREE.WebGLRenderer();
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.shadowMap.enabled = true;
		renderer.shadowMap.type = THREE.BasicShadowMap;
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setClearColor(0x000000, 1);
		document.body.insertBefore(renderer.domElement, document.body.firstChild);

		//++++++++++++++++++++++++++++++++++++++++++++
		//++++++++++++++++++++++++++++++++++++++++++++
		var light = new THREE.AmbientLight(0x111111); // soft white light
		scene.add(light);

		var spotLight = new THREE.SpotLight(0xffffff);
		spotLight.position.set(1, 20, 10);
		spotLight.castShadow = true;
		spotLight.shadowCameraNear = 8;
		spotLight.shadowCameraFar = 30;
		spotLight.shadowMapWidth = 1024;
		spotLight.shadowMapHeight = 1024;
		spotLight.angle = 1;
		spotLight.exponent = 5;
		spotLight.shadowDarkness = 1;
		spotLight.name = 'SpotLight';

		var pointLightOne = new THREE.PointLight(0xff0000);
		pointLightOne.position.set(1, 1, 10);

		scene.add( light, spotLight, pointLightOne);

		//++++++++++++++++++++++++++++++++++++++++++++
		//++++++++++++++++++++++++++++++++++++++++++++
		//CONTROLS

		controls = new THREE.FirstPersonControls( camera );
		        controls.movementSpeed = 40;
		        controls.lookSpeed = 0.1;
		        controls.lookVertical = false;

		lastTime = performance.now();
	
		//++++++++++++++++++++++++++++++++++++++++++++
		//++++++++++++++++++++++++++++++++++++++++++++
		//RESIZER
		var onWindowResize = function(event) {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
		}


		//////////////////////////////////////////////////////////////////////////////////
		//    oimo world              //
		//////////////////////////////////////////////////////////////////////////////////
		var world = new OIMO.World(1/120, 2, 8)
		setInterval(function(){ world.step() }, 1000/60);

		//++++++++++++++++++++++++++++++++++++++++++++
		//++++++++++++++++++++++++++++++++++++++++++++
		//OBJECTS
		phongMaterial = new THREE.MeshPhongMaterial({ color: 0x156289, emissive: 0x072534 });
		material = new THREE.MeshBasicMaterial({ name: 'green-wire', color: 0x00ff00, wireframe: true });
		var planeMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff, emissive: 0x072534, shininess: 100, side: THREE.DoubleSide, shading: THREE.SmoothShading });

		var planeGeometry = new THREE.PlaneGeometry(100, 100, 1);
		var ground = new THREE.Mesh(planeGeometry, planeMaterial);
		ground.rotateX( - Math.PI / 2 );
		ground.position.y = -2;
		ground.scale.x = 100;
		ground.scale.y = 100;
		ground.castShadow = false;
		ground.receiveShadow = true;
		ground.name = 'Ground'

		scene.add(ground);

		cubeGeometry = new THREE.BoxGeometry(1, 1, 1);

		var cubeHolder = []; //holds some cube info

		var cubeCreate = function(cubeName) {
			this.cubeName = cubeName;

			this.cubeRotation = true;

			this.cube = new THREE.Mesh(cubeGeometry, material);

			this.cube.castShadow = true;


			this.cube.name = 'Cube'

			scene.add(this.cube);

			return this.cubeName;
		}

		var cubeRemove = function() {
			//removes all cubes - or at least trys to.

			for (var i = 0; i < scene.children.length; i++) {

			    for (var j = 0; j < cubeHolder.length; j++) {
			        if (scene.children[i].id === cubeHolder[j].cube.id) {
			            scene.children.splice(i, 1);
			            cubeHolder.splice(j, 1);
			        }

			    }

			}
		}

		//++++++++++++++++++++++++++++++++++++++++++++
		//++++++++++++++++++++++++++++++++++++++++++++
		//RANDOM CUBE SYSTEM
		var boxBody;
		var boxBodies = [];
		for ( var i = 0; i < 1000; i ++ ) {

			var boxGeometry = new THREE.BoxGeometry(10, 10, 10);
			var randomColor = '0x' + Math.floor(Math.random()*16777215).toString(16);
			var cubeSystemMaterial = new THREE.MeshPhongMaterial( {  specular: 0x111111, 
			                                                    emissive: 0x040404, 
			                                                    shininess: 100, 
			                                                    shading: THREE.SmoothShading, 
			                                                    opacity: 0.9, 
			                                                    transparent: true });

			var object = new THREE.Mesh( boxGeometry, cubeSystemMaterial );

			var plusMinus = Math.floor(Math.random()*2) == 1 ? 1 : -1;
			object.material.color.setHex(randomColor);

			object.position.x = (Math.random() * 1000) * plusMinus + 100;
			object.position.y = 0;
			object.position.z = (Math.random() * 1000) +100;
			object.scale.y = Math.random() + 5;
			object.castShadow = true;
			object.name = 'CubeSystem';
			scene.add( object );

			objects.push(object);
			boxBody  = THREEx.Oimo.createBodyFromMesh(world, object, {move: false});
			boxBodies.push(boxBody);

		}    

		//++++++++++++++++++++++++++++++++++++++++++++
		//++++++++++++++++++++++++++++++++++++++++++++
		//Person
		var test = new THREE.Mesh(cubeGeometry, material);
		controls.object.add(test);
		var person = controls.object.children[0];
		var personView = THREEx.Oimo.createBodyFromMesh(world, person, {move: false});

		//++++++++++++++++++++++++++++++++++++++++++++
		//++++++++++++++++++++++++++++++++++++++++++++
		//PARTICLE - Star Like in Background

		var sprite = THREE.ImageUtils.loadTexture("<%= asset_path 'textures/disc.png' %>");
		var particleCount = 8000,
		particles = new THREE.Geometry(),
		particleMaterial = new THREE.PointsMaterial({
		size: 6,
		sizeAttenuation: false,
		map: sprite,
		alphaTest: 0.5,
		transparent: true
		});

		particleMaterial.color.setHSL(1.0, 5, 0.7);

		for (var p = 0; p < particleCount; p++) {

			var pX = Math.random() * 5500 - 250,
			pY = Math.random() * 1500 - 250,
			pZ = Math.random() * 5500 - 250,
			particle = new THREE.Vector3(pX, pY, pZ);
			particle.velocity = new THREE.Vector3( 0, -Math.random(), 0 );
			particles.vertices.push( particle );

		}

		// create the particle system
		var particleSystem = new THREE.Points( particles, particleMaterial);

		// add it to the scene
		scene.add(particleSystem);



		//===========================================================
		//===========================================================
		//===========================================================
		var h;
		var randomColor = '0x' + Math.floor(Math.random() * 16777215).toString(16);
		//RENDER & ANIMATE SCENE
		var render = function() {
			requestAnimationFrame(render);


			console.log();
			for(var i = 0; i < objects.length; i++ ) {

			if ( controls.object.position.distanceTo(objects[i].position) < 8  ) {

			    console.log('HIT');
			    controls.freeze = true;
			    if ( controls.moveBackward || controls.moveLeft || controls.moveRight ){
			        controls.freeze = false;
			    }
			}
			}

			THREEx.Oimo.updateObject3dWithBody(person, personView);

			var time = Date.now() * 0.00005;
			h = (360 * (1.0 + time) % 360) / 360;
			material.color.setHSL(h, 0.5, 0.5);

			particleMaterial.color.setHSL(h, 0.5, 0.5);
	
			for (i = 0; i < objects.length; i++) {
				var object = objects[i];
			}

			//Particle SYstem
			for (i = 0; i < scene.children.length; i++) {

				var object = scene.children[i];

				var pCount = particleCount;

				if (object instanceof THREE.Points) {

				    object.rotation.y += 0.0008;

				}
				
				if (object instanceof THREE.PointLight) {

			  	  object.color.setHSL(h, 0.5, 0.5);

				}

		}

		//CUBE MOVEMENT - AND GROWING
		for (var i = 0; i < scene.children.length; i++) {

			if (scene.children[i].name === "Cube" && scene.children[i].id % 2 === 0) {

			    scene.children[i].rotation.x += Math.random() * .1;
			    scene.children[i].rotation.y += 0.01;
			    scene.children[i].position.x += 0.01;
			    scene.children[i].position.y += 0.01;
			    scene.children[i].scale.y += 0.01;
			    

			} else if (scene.children[i].name === "Cube" && scene.children[i].id % 2 === 1) {

			    scene.children[i].rotation.x -= Math.random() * .1;
			    scene.children[i].rotation.y -= 0.01;
			    scene.children[i].position.x -= 0.01;
			    scene.children[i].position.y += 0.01;
			    scene.children[i].scale.y += 0.01;

			}
		}

		var timeAlso = performance.now() / 1000;
		controls.update( timeAlso - lastTime ); 
		// controls.update();
		renderer.render(scene, camera);
		lastTime = timeAlso;
		};

		// Create a new instance of an audio object and adjust some of its properties
		var audio = new Audio();
		audio.src = "<%= asset_path 'AlsoSprachZarathustra.mp3' %>";
		audio.controls = true;
		audio.loop = true;
		audio.autoplay = true;

		// Establish all variables that your Analyser will use
		var canvas, ctx, source, context, analyser, fbc_array, bars, bar_x, bar_width, bar_height;

		// Initialize the MP3 player after the page loads all of its HTML into the window
		window.addEventListener("load", initMp3Player, false);
		var frameLooper = function (){
		    window.requestAnimationFrame(frameLooper);
		    fbc_array = new Uint8Array(analyser.frequencyBinCount);
		    analyser.getByteFrequencyData(fbc_array);
		    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
		    ctx.fillStyle = '#00CCFF'; // Color of the bars
		    

		    bars = 100;
		    
		    for (var i = 0; i < objects.length; i++) {
		        bar_x = i * 3;
		        bar_width = Math.random() * fbc_array[i] / 2;
		        bar_height = -fbc_array[i];
		        
		        objects[i].position.y = -1 * (bar_height + 1);
		        
		        //  fillRect( x, y, width, height ) // Explanation of the parameters below
		        ctx.fillRect(bar_x, canvas.height, bar_width, bar_height);
		    }
		}

		var initMp3Player = function (){
		    document.getElementById('audio_box').appendChild(audio);
		    context = new AudioContext(); // AudioContext object instance
		    analyser = context.createAnalyser(); // AnalyserNode method
		    canvas = document.getElementById('analyser_render');
		    ctx = canvas.getContext('2d');
		    // Re-route audio playback into the processing graph of the AudioContext
		    source = context.createMediaElementSource(audio); 
		    source.connect(analyser);
		    analyser.connect(context.destination);
		    frameLooper();
		}


		$(document).ready(function() {

		render();
		initMp3Player();

		window.addEventListener('resize', onWindowResize, false);

		$('#addBoxes').on('click', function() {

			var a = new cubeCreate(cubeHolder.length.toString());
			cubeHolder.push(a);
			console.log('CUBE HOLDER Length:', cubeHolder.length);

		});

		$('#removeBoxes').on('click', function() {

		cubeRemove();

		});

		setInterval(function() {
			var a = new cubeCreate(cubeHolder.length.toString());
			cubeHolder.push(a);


			if (cubeHolder.length === 100) {

			    var theCube = cubeHolder[0].cube.id;
			    cubeHolder.shift();

			    _.each(scene.children, function(object, i) {
			        if (scene.children[i].id === theCube) {
			            scene.children.splice(i, 1);
			        }
			    });
			    console.log('A CUBE HAS BEEN REMOVED');

			    // cubeRemove();
			}
		}, 2000);

		});

		return (<div>HELLO</div>);
	}
}); 
